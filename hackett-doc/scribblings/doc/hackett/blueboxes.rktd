6619
((3) 0 () 14 ((q lib "hackett/main.rkt") (q lib "hackett/monad/reader.rkt") (q 3924 . 2) (q 3236 . 2) (q 3205 . 2) (q lib "hackett/data/identity.rkt") (q 3446 . 2) (q lib "hackett/monad/trans.rkt") (q lib "hackett/monad/error.rkt") (q 4450 . 2) (q 8751 . 2) (q 3713 . 2) (q 3554 . 2) (q 8297 . 2)) () (h ! (equal) ((c def c (c (? . 0) q ++)) q (6182 . 2)) ((c def c (c (? . 0) q const)) q (2668 . 2)) ((c form c (c (? . 0) q #%hackett-type:∀)) q (3082 . 3)) ((c form c (c (? . 0) q def)) q (184 . 11)) ((c def c (c (? . 0) q take)) q (4739 . 4)) ((c def c (c (? . 0) q #%hackett-type:Either)) c (? . 2)) ((c def c (c (? . 0) q ::)) c (? . 9)) ((c form c (c (? . 0) q class)) q (5241 . 9)) ((c def c (c (? . 0) q >>=)) q (7660 . 3)) ((c def c (c (? . 1) q run-reader-t)) q (8361 . 4)) ((c def c (c (? . 0) q if)) q (3308 . 2)) ((c def c (c (? . 0) q <$)) q (6642 . 2)) ((c def c (c (? . 0) q filter)) q (4895 . 4)) ((c def c (c (? . 0) q =<<)) q (7586 . 2)) ((c def c (c (? . 0) q tail!)) q (4681 . 2)) ((c def c (c (? . 0) q snd)) q (3658 . 2)) ((c def c (c (? . 0) q join)) q (7530 . 2)) ((c def c (c (? . 0) q undefined!)) q (9259 . 2)) ((c def c (c (? . 0) q #%hackett-type:Applicative)) q (6879 . 3)) ((c def c (c (? . 1) q ask)) q (8537 . 2)) ((c form c (c (? . 0) q lambda*)) q (856 . 2)) ((c def c (c (? . 0) q <*>)) q (7081 . 2)) ((c def c (c (? . 0) q println)) q (8096 . 3)) ((c def c (c (? . 0) q #%hackett-type:Unit)) c (? . 4)) ((c def c (c (? . 0) q rights)) q (4275 . 3)) ((c def c (c (? . 0) q -)) q (2011 . 2)) ((c def c (c (? . 0) q #%hackett-type:Monoid)) q (6213 . 2)) ((c def c (c (? . 0) q is-left)) q (4087 . 3)) ((c form c (c (? . 0) q #%hackett-type:=>)) q (3167 . 2)) ((c def c (c (? . 0) q fst)) q (3603 . 2)) ((c def c (c (? . 0) q <$>)) q (6460 . 3)) ((c def c (c (? . 0) q d+)) q (2303 . 2)) ((c def c (c (? . 0) q traverse)) q (7252 . 3)) ((c def c (c (? . 0) q either)) q (3985 . 5)) ((c def c (c (? . 0) q sum)) q (5181 . 3)) ((c def c (c (? . 0) q Right)) c (? . 2)) ((c def c (c (? . 0) q False)) c (? . 3)) ((c def c (c (? . 0) q >=)) q (2197 . 2)) ((c def c (c (? . 0) q tail)) q (4565 . 2)) ((c form c (c (? . 0) q #%hackett-type:Double)) q (2289 . 2)) ((c form c (c (? . 0) q data)) q (1328 . 16)) ((c def c (c (? . 1) q ReaderT)) c (? . 13)) ((c def c (c (? . 0) q pure)) q (7035 . 2)) ((c def c (c (? . 7) q lift)) q (8240 . 2)) ((c form c (c (? . 0) q let)) q (958 . 6)) ((c def c (c (? . 5) q Identity)) c (? . 6)) ((c def c (c (? . 0) q True)) c (? . 3)) ((c def c (c (? . 0) q <&>)) q (6551 . 3)) ((c def c (c (? . 0) q >)) q (2107 . 2)) ((c def c (c (? . 0) q *)) q (2059 . 2)) ((c form c (c (? . 0) q #%hackett-type:->)) q (2611 . 2)) ((c def c (c (? . 0) q Unit)) c (? . 4)) ((c form c (c (? . 0) q todo!)) q (9297 . 2)) ((c def c (c (? . 0) q show)) q (5999 . 2)) ((c def c (c (? . 5) q #%hackett-type:Identity)) c (? . 6)) ((c form c (c (? . 0) q λ*)) q (909 . 2)) ((c def c (c (? . 0) q lefts)) q (4204 . 3)) ((c def c (c (? . 7) q #%hackett-type:MonadTrans)) q (8156 . 2)) ((c def c (c (? . 0) q $)) q (2800 . 2)) ((c def c (c (? . 0) q ==)) q (6087 . 2)) ((c def c (c (? . 1) q local)) q (8653 . 4)) ((c form c (c (? . 0) q case)) q (1173 . 3)) ((c def c (c (? . 8) q ErrorT)) c (? . 10)) ((c def c (c (? . 0) q Left)) c (? . 2)) ((c def c (c (? . 0) q flip)) q (2914 . 2)) ((c def c (c (? . 0) q ap)) q (7872 . 3)) ((c form c (c (? . 0) q lambda)) q (772 . 2)) ((c def c (c (? . 0) q map)) q (6391 . 2)) ((c def c (c (? . 0) q &)) q (2857 . 2)) ((c def c (c (? . 0) q ignore)) q (6802 . 2)) ((c def c (c (? . 0) q foldr)) q (4981 . 5)) ((c def c (c (? . 0) q <)) q (2152 . 2)) ((c form c (c (? . 0) q :)) q (161 . 2)) ((c form c (c (? . 0) q instance)) q (5583 . 10)) ((c def c (c (? . 5) q run-identity)) q (3495 . 3)) ((c def c (c (? . 0) q #%hackett-type:Tuple)) c (? . 12)) ((c def c (c (? . 8) q catch)) q (9035 . 4)) ((c form c (c (? . 0) q #%hackett-type:forall)) q (2991 . 3)) ((c def c (c (? . 0) q #%hackett-type:Bool)) c (? . 3)) ((c def c (c (? . 0) q from-maybe)) q (3855 . 4)) ((c def c (c (? . 0) q partition-eithers)) q (4347 . 3)) ((c form c (c (? . 0) q letrec)) q (1064 . 6)) ((c def c (c (? . 0) q Nil)) c (? . 9)) ((c def c (c (? . 0) q head)) q (4507 . 2)) ((c def c (c (? . 0) q id)) q (2629 . 2)) ((c form c (c (? . 0) q #%hackett-type:Integer)) q (1948 . 2)) ((c def c (c (? . 0) q d*)) q (2395 . 2)) ((c def c (c (? . 0) q #%hackett-type:Functor)) q (6301 . 3)) ((c def c (c (? . 0) q sequence)) q (7155 . 3)) ((c def c (c (? . 0) q #%hackett-type:Show)) q (5941 . 2)) ((c def c (c (? . 0) q foldl)) q (5081 . 5)) ((c form c (c (? . 0) q #%hackett-type:String)) q (2487 . 2)) ((c def c (c (? . 0) q #%hackett-type:Monad)) q (7368 . 3)) ((c def c (c (? . 0) q \|\|)) q (3364 . 2)) ((c def c (c (? . 0) q #%hackett-type:Eq)) q (6030 . 2)) ((c def c (c (? . 0) q not)) q (3277 . 2)) ((c form c (c (? . 0) q defn)) q (463 . 12)) ((c def c (c (? . 0) q string-split)) q (2547 . 2)) ((c def c (c (? . 0) q seq)) q (9161 . 2)) ((c def c (c (? . 0) q print)) q (8038 . 3)) ((c form c (c (? . 0) q do)) q (7754 . 5)) ((c def c (c (? . 8) q run-error)) q (8897 . 3)) ((c def c (c (? . 0) q d-)) q (2349 . 2)) ((c def c (c (? . 0) q #%hackett-type:List)) c (? . 9)) ((c def c (c (? . 0) q #%hackett-type:Semigroup)) q (6121 . 2)) ((c def c (c (? . 0) q +)) q (1963 . 2)) ((c def c (c (? . 0) q &&)) q (3406 . 2)) ((c form c (c (? . 0) q main)) q (7990 . 4)) ((c def c (c (? . 0) q is-right)) q (4145 . 3)) ((c form c (c (? . 0) q case*)) q (1224 . 3)) ((c def c (c (? . 0) q mempty)) q (6282 . 2)) ((c def c (c (? . 0) q error!)) q (9211 . 2)) ((c def c (c (? . 8) q throw)) q (8977 . 3)) ((c def c (c (? . 0) q Just)) c (? . 11)) ((c def c (c (? . 0) q maybe)) q (3767 . 5)) ((c def c (c (? . 0) q string-length)) q (2501 . 2)) ((c form c (c (? . 0) q #%hackett-type:IO)) q (7965 . 2)) ((c def c (c (? . 0) q drop)) q (4817 . 4)) ((c def c (c (? . 8) q #%hackett-type:ErrorT)) c (? . 10)) ((c form c (c (? . 0) q λ)) q (816 . 2)) ((c def c (c (? . 0) q #%hackett-type:Maybe)) c (? . 11)) ((c def c (c (? . 0) q |.|)) q (2720 . 2)) ((c def c (c (? . 0) q <=)) q (2243 . 2)) ((c form c (c (? . 0) q require)) q (1292 . 2)) ((c def c (c (? . 0) q $>)) q (6722 . 2)) ((c def c (c (? . 0) q head!)) q (4631 . 2)) ((c def c (c (? . 8) q run-error-t)) q (8817 . 3)) ((c def c (c (? . 1) q run-reader)) q (8449 . 4)) ((c def c (c (? . 0) q Tuple)) c (? . 12)) ((c def c (c (? . 0) q Nothing)) c (? . 11)) ((c def c (c (? . 1) q asks)) q (8588 . 3)) ((c def c (c (? . 1) q #%hackett-type:ReaderT)) c (? . 13)) ((c def c (c (? . 0) q d/)) q (2441 . 2))))

(function-expr arg-expr)

(function-expr arg-expr ...+)
value
Nil : (forall [a] (List a))
value
:: : (forall [a] {a -> (List a) -> (List a)})
syntax
(: expr type)
syntax
(def id maybe-type maybe-fixity-ann val-expr)
 
      maybe-type = : type
                 | 
                    
maybe-fixity-ann = #:fixity fixity
                 | 
                    
          fixity = left
                 | right
syntax
(defn id maybe-type maybe-fixity-ann
  [[arg-pat ...+] body-expr] ...+)
 
      maybe-type = : type
                 | 
                    
maybe-fixity-ann = #:fixity fixity
                 | 
                    
          fixity = left
                 | right
syntax
(lambda [arg-pat ...+] body-expr)
syntax
(λ [arg-pat ...+] body-expr)
syntax
(lambda* [[arg-pat ...+] body-expr] ...+)
syntax
(λ* [[arg-pat ...+] body-expr] ...+)
syntax
(let ([id maybe-type val-expr] ...+)
  body-expr)
 
maybe-type = : type
           | 
syntax
(letrec ([id maybe-type val-expr] ...+)
  body-expr)
 
maybe-type = : type
           | 
syntax
(case val-expr
  [pat body-expr] ...+)
syntax
(case* [val-expr ...+]
  [[pat ...+] body-expr] ...+)
syntax
(require require-spec ...)
syntax
(data type-clause data-clause ...)
 
     type-clause = type-id
                 | (type-constructor-id param-id ...+) maybe-fixity-ann
                 | {param-id type-constructor-id param-id} maybe-fixity-ann
                    
     data-clause = value-id
                 | (data-constructor-id arg-type ...+) maybe-fixity-ann
                 | {arg-type data-constructor-id arg-type} maybe-fixity-ann
                    
maybe-fixity-ann = #:fixity fixity
                 | 
                    
          fixity = left
                 | right
syntax
Integer
value
+ : {Integer -> Integer -> Integer}
value
- : {Integer -> Integer -> Integer}
value
* : {Integer -> Integer -> Integer}
value
> : {Integer -> Integer -> Bool}
value
< : {Integer -> Integer -> Bool}
value
>= : {Integer -> Integer -> Bool}
value
<= : {Integer -> Integer -> Bool}
syntax
Double
value
d+ : {Double -> Double -> Double}
value
d- : {Double -> Double -> Double}
value
d* : {Double -> Double -> Double}
value
d/ : {Double -> Double -> Double}
syntax
String
value
string-length : {String -> Integer}
value
string-split : {String -> String -> (List String)}
syntax
(-> a b)
value
id : (forall [a] {a -> a})
value
const : (forall [a b] {a -> b -> a})
value
|.| : (forall [a b c] {{b -> c} -> {a -> b} -> {a -> c}})
value
$ : (forall [a b] {{a -> b} -> a -> b})
value
& : (forall [a b] {a -> {a -> b} -> b})
value
flip : (forall [a b c] {{a -> b -> c} -> b -> a -> c})
syntax
(forall [var-id ...+] type)
(forall [var-id ...+] constraint ...+ => type)
syntax
(∀ [var-id ...+] type)
(∀ [var-id ...+] constraint ...+ => type)
syntax
(=> [constraint ...+] type)
datatype
(data Unit   Unit)
datatype
(data Bool   True   False)
value
not : {Bool -> Bool}
value
if : (forall [a] {Bool -> a -> a -> a})
value
\|\| : {Bool -> Bool -> Bool}
value
&& : {Bool -> Bool -> Bool}
datatype
(data (Identity a)   (Identity a))
procedure
(run-identity x) -> a
  x : (Identity a)
datatype
(data (Tuple a b)   (Tuple a b))
value
fst : (forall [a b] {(Tuple a b) -> a})
value
snd : (forall [a b] {(Tuple a b) -> b})
datatype
(data (Maybe a)   (Just a)   Nothing)
procedure
(maybe v f x) -> b
  v : b
  f : {a -> b}
  x : (Maybe a)
procedure
(from-maybe v x) -> a
  v : a
  x : (Maybe a)
datatype
(data (Either a b)   (Left a)   (Right b))
procedure
(either f g x) -> c
  f : {a -> c}
  g : {b -> c}
  x : (Either a b)
procedure
(is-left e) -> Bool
  e : (Either a b)
procedure
(is-right e) -> Bool
  e : (Either a b)
procedure
(lefts es) -> (List a)
  es : (List (Either a b))
procedure
(rights es) -> (List b)
  es : (List (Either a b))
procedure
(partition-eithers es) -> (Tuple (List a) (List b))
  es : (List (Either a b))
datatype
(data (List a)   (:: a (List a))   Nil)
value
head : (forall [a] {(List a) -> (Maybe a)})
value
tail : (forall [a] {(List a) -> (Maybe (List a))})
value
head! : (forall [a] {(List a) -> a})
value
tail! : (forall [a] {(List a) -> (List a)})
procedure
(take n xs) -> (List a)
  n : Integer
  xs : (List a)
procedure
(drop n xs) -> (List a)
  n : Integer
  xs : (List a)
procedure
(filter f xs) -> (List a)
  f : {a -> Bool}
  xs : (List a)
procedure
(foldr f acc xs) -> b
  f : {a -> b -> b}
  acc : b
  xs : (List a)
procedure
(foldl f acc xs) -> b
  f : {b -> a -> b}
  acc : b
  xs : (List a)
procedure
(sum xs) -> Integer
  xs : (List Integer)
syntax
(class maybe-superclasses (class-id var-id ...)
  [method-id : method-type maybe-default-method-impl] ...)
 
       maybe-superclasses = superclass-constraint ... =>
                          | 
                             
maybe-default-method-impl = default-method-impl-expr
                          | 
syntax
(instance instance-spec
  [method-id method-expr] ...)
 
    instance-spec = (class-id instance-type ...)
                  | (forall [var-id ...] maybe-constraints
                            (class-id instance-type ...))
                     
maybe-constraints = instance-constraint ... =>
                  | 
typeclass
(class (Show a)   [show : {a -> String}])
value
show : {a -> String}
typeclass
(class (Eq a)   [== : {a -> a -> Bool}])
value
== : {a -> a -> Bool}
typeclass
(class (Semigroup a)   [++ : {a -> a -> a}])
value
++ : {a -> a -> a}
typeclass
(class (Semigroup a) => (Monoid a)   [mempty : a])
value
mempty : a
typeclass
(class (Functor f)   [map : (forall [a b] {{a -> b} -> (f a) -> (f
b)})])
value
map : (forall [a b] {{a -> b} -> (f a) -> (f b)})
value
<$>
 : (forall [f a b] (Functor f) => {{a -> b} -> (f a) -> (f b)})
value
<&>
 : (forall [f a b] (Functor f) => {(f a) -> {a -> b} -> (f b)})
value
<$ : (forall [f a b] (Functor f) => {b -> (f a) -> (f b)})
value
$> : (forall [f a b] (Functor f) => {(f a) -> b -> (f b)})
value
ignore : (forall [f a] (Functor f) => {(f a) -> (f Unit)})
typeclass
(class (Functor f) => (Applicative f)   [pure : (forall [a] {a -> (f
a)})]   [<*> : (forall [a b] {(f {a -> b}) -> (f a) -> (f b)})])
value
pure : (forall [a] {a -> (f a)})
value
<*> : (forall [a b] {(f {a -> b}) -> (f a) -> (f b)})
value
sequence
 : (forall [f a] (Applicative f) => {(List (f a)) -> (f (List a))})
value
traverse
 : (forall [f a b] (Applicative f) => {{a -> (f b)} -> (List a) -> (f (List b))})
typeclass
(class (Applicative m) => (Monad m)   [join : (forall [a] {(m (m a)) ->
(m a)})]   [=<< : (forall [a b] {{a -> (m b)} -> (m a) -> (m b)})])
value
join : (forall [a] {(m (m a)) -> (m a)})
value
=<< : (forall [a b] {{a -> (m b)} -> (m a) -> (m b)})
value
>>=
 : (forall [m a b] (Monad m) => {(m a) -> {a -> (m b)} -> (m b)})
syntax
(do do-clause ... monadic-expr)
 
do-clause = [binding-id <- monadic-expr]
          | monadic-expr
value
ap
 : (forall [m a b] (Monad m) => {(m {a -> b}) -> (m a) -> (m b)})
type constructor
(IO a)
syntax
(main action)
 
  action : (IO a)
procedure
(print str) -> (IO Unit)
  str : String
procedure
(println str) -> (IO Unit)
  str : String
typeclass
(class (MonadTrans t)   [lift : (forall [m a] {(m a) -> (t m a)})])
value
lift : (forall [m a] {(m a) -> (t m a)})
datatype
(data (ReaderT r m a)   (ReaderT {r -> (m a)}))
procedure
(run-reader-t x ctx) -> (m a)
  x : (ReaderT r m a)
  ctx : r
procedure
(run-reader x ctx) -> a
  x : (ReaderT r Identity a)
  ctx : r
value
ask : (forall [r m] (ReaderT r m r))
procedure
(asks f) -> (ReaderT r m a)
  f : {r -> a}
procedure
(local f x) -> (ReaderT r m a)
  f : {r -> r}
  x : (ReaderT r m a)
datatype
(data (ErrorT e m a)   (ErrorT (m (Either e a))))
procedure
(run-error-t x) -> (m (Either e a))
  x : (ErrorT e m a)
procedure
(run-error x) -> (Either e a)
  x : (ErrorT e Identity a)
procedure
(throw ex) -> (ErrorT e m a)
  ex : e
procedure
(catch x handler) -> (ErrorT e* m a)
  x : (ErrorT e m a)
  handler : {e -> (ErrorT e* m a)}
value
seq : (forall [a b] {a -> b -> b})
value
error! : (forall [a] {String -> a})
value
undefined! : (forall [a] a)
syntax
(todo! form ...)
